# Постановка завдання

Набір з 1000 картинок одночасно редагують 3 людини.

Їхня швидкість відрізняється:
- 1 картинка за 2 хвилини
- 1 картинка за 3 хвилини
- 1 картинка за 4 хвилини

**Питання: за який час вони виконають цю роботу разом?**

Вимоги:

- Дати правильну відповідь і пояснити кроки виконання завдання.
- Написати код, який працює для різних кількостей людей і картинок.

Врахувати: ООП, багаторівневу архітектуру, тести, правила програмування.

## Перший погляд на завдання 

Математично від нас хочуть 1000 : (1/2 + 1/3 + 1/4).

## Другий погляд на завдання

Тут йдеться про взаємодію сутностей. Окрім чисел ми ще маємо маніпулювати _логікою_ - тим, як об'єкти взаємодіють. Більше того, тут присутня логіка ***одночасного виконання*** - і ось її змоделювати буде цікаво.

### Дані, з якими ми працюємо

Я виходжу з того, що проект так чи інакше повинен починатися з повного абстрагування. Спершу ми створюємо повністю абстрактні класи `Job` та `Worker`. Уже від них наслідуватимуться будь-які інші пари по логіці **"завдання / виконавець"**. Клас `Job` не знає нічого ні про кого, а ось клас `Worker` уже мусить знати, скільки часу йому знадобиться для того, щоб виконати один `Job`. Але як вони взаємодіятимуть?

### Логіка виконання роботи

У нашому випадку декілька людей працюють одночасно. Йдеться про _багатопоточність_. Кожна людина працює зі своєю швидкістю, вона є динамічною і ми не можемо передбачити, у який момент та чи інша людина дістанеться певного завдання. Тобто, ми не можемо просто зберігати `Job` у звичайному масиві чи списку. Нам потрібна динамічна черга, до якої може звертатися будь-коли будь-хто.

У .NET таку чергу реалізує клас `System.Threading.Channels.Channel`. Він за допомогою `Writer` може прийняти довільну кількість завдань, і через `Reader` віддавати ці завдання будь-якій кількості тих, хто на них чекає. На кожне завдання працівник за допомогою `Task.Delay` витрачає час, який передбачений особистою швидкістю.  

Отже, ззовні моделі я створюю його екземпляр і записую туди завдання через `Writer`. Далі від кожного працівника я викликаю метод, який слухає його `Reader` і забирає звідти завдання доти, доки вони ще є у черзі. 

Варто розуміти, що всі ці завдання асинхронні і їхня логіка вибудована так, що кожен рівень вкладеності мусить "чекати" (`await`) свої внутрішні `Task` і повертати результати назовні, це виглядає як **ланцюгова реакція**.

### Коли фундамент збудовано 

Тепер магія полягає у тому, що з цього моменту ми можемо віднаслідуватись класами `Image` та `Person` від абстрактних `Job` та `Worker` і запустити виконання на них. Ще одна магія полягає у тому, що використовуючи не теоретичний спосіб (діленням), а емпіричний (потоками) ця симуляція дає той же результат, що і ділення.

### Випробування розширюваності

За цією ж логікою у рішення додано декілька абсолютно інших сутностей, як-от "кур'єр / посилка" або "комбайн / картоплина". Це підсвідомо - роздуми на випадок того, якщо ви відхилите мою кандидатуру :D
